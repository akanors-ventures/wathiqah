generator client {
  provider     = "prisma-client"
  output       = "../src/generated/prisma"
  moduleFormat = "cjs"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                         String               @id @default(uuid())
  email                      String               @unique
  passwordHash               String?
  createdAt                  DateTime             @default(now())
  refreshTokenHash           String?
  isEmailVerified            Boolean              @default(false)
  firstName                  String
  lastName                   String
  phoneNumber                String?
  preferredCurrency          String               @default("NGN")
  tier                       SubscriptionTier     @default(FREE)
  subscriptionStatus         String?
  subscriptionId             String?
  featureUsage               Json?                @default("{}")
  isSupporter                Boolean              @default(false)
  accessGrants               AccessGrant[]
  contactInvitationsReceived ContactInvitation[]  @relation("InvitedUser")
  contactInvitationsSent     ContactInvitation[]  @relation("InviterUser")
  linkedContacts             Contact[]            @relation("ContactLinkedUser")
  contacts                   Contact[]
  projects                   Project[]
  promises                   Promise[]
  transactionHistory         TransactionHistory[] @relation("HistoryUser")
  transactions               Transaction[]        @relation("TransactionCreator")
  witnessRecords             Witness[]            @relation("WitnessUser")
  supports                   Support[]
  payments                   Payment[]
  subscription               Subscription?

  @@index([phoneNumber])
  @@map("users")
}

model Subscription {
  id                 String           @id @default(uuid())
  userId             String           @unique
  tier               SubscriptionTier @default(FREE)
  status             String // active, trialing, past_due, canceled, unpaid
  provider           String // stripe, flutterwave, lemonsqueezy
  externalId         String?          @unique // Stripe Subscription ID or Flutterwave ID
  planId             String? // The ID of the plan/price
  currentPeriodStart DateTime?
  currentPeriodEnd   DateTime?
  cancelAtPeriodEnd  Boolean          @default(false)
  canceledAt         DateTime?
  endedAt            DateTime?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@map("subscriptions")
}

model Payment {
  id         String        @id @default(uuid())
  userId     String
  amount     Decimal       @db.Decimal(10, 2)
  currency   String
  status     PaymentStatus @default(PENDING)
  provider   String // stripe, flutterwave
  externalId String?       @unique // Stripe PaymentIntent ID or Flutterwave Ref
  type       PaymentType // SUBSCRIPTION, CONTRIBUTION
  metadata   Json?
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([provider])
  @@index([status])
  @@index([createdAt])
  @@map("payments")
}

model WebhookLog {
  id         String   @id @default(uuid())
  provider   String // stripe, flutterwave
  externalId String? // Event ID from provider
  type       String // Event type (e.g., checkout.session.completed)
  payload    Json
  status     String // processed, failed, pending
  error      String?
  createdAt  DateTime @default(now())

  @@map("webhook_logs")
}

enum PaymentStatus {
  PENDING
  SUCCESSFUL
  FAILED
  REFUNDED
}

enum PaymentType {
  SUBSCRIPTION
  SUPPORT
}

model Contact {
  id           String              @id @default(uuid())
  email        String?
  phoneNumber  String?
  createdAt    DateTime            @default(now())
  userId       String
  firstName    String
  lastName     String
  linkedUserId String?
  invitations  ContactInvitation[]
  linkedUser   User?               @relation("ContactLinkedUser", fields: [linkedUserId], references: [id])
  user         User                @relation(fields: [userId], references: [id])
  transactions Transaction[]

  @@map("contacts")
}

model Transaction {
  id              String               @id @default(uuid())
  category        AssetCategory        @default(FUNDS)
  amount          Decimal?             @db.Decimal(10, 2)
  itemName        String?
  quantity        Int?                 @default(1)
  type            TransactionType
  date            DateTime
  description     String?
  createdAt       DateTime             @default(now())
  contactId       String?
  createdById     String
  status          TransactionStatus    @default(COMPLETED)
  returnDirection ReturnDirection?
  parentId        String?
  currency        String               @default("NGN")
  history         TransactionHistory[]
  contact         Contact?             @relation(fields: [contactId], references: [id])
  createdBy       User                 @relation("TransactionCreator", fields: [createdById], references: [id])
  parent          Transaction?         @relation("TransactionConversion", fields: [parentId], references: [id])
  conversions     Transaction[]        @relation("TransactionConversion")
  witnesses       Witness[]

  @@map("transactions")
}

model TransactionHistory {
  id            String      @id @default(uuid())
  transactionId String
  userId        String
  previousState Json
  newState      Json
  changeType    String
  createdAt     DateTime    @default(now())
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  user          User        @relation("HistoryUser", fields: [userId], references: [id])

  @@map("transaction_history")
}

model Witness {
  id                   String              @id @default(uuid())
  status               WitnessStatus       @default(PENDING)
  invitedAt            DateTime            @default(now())
  acknowledgedAt       DateTime?
  transactionId        String?
  projectTransactionId String?
  userId               String
  transaction          Transaction?        @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  projectTransaction   ProjectTransaction? @relation(fields: [projectTransactionId], references: [id], onDelete: Cascade)
  user                 User                @relation("WitnessUser", fields: [userId], references: [id])

  @@unique([transactionId, userId])
  @@unique([projectTransactionId, userId])
  @@map("witnesses")
}

model Project {
  id           String               @id @default(uuid())
  name         String
  description  String?
  budget       Decimal?             @db.Decimal(10, 2)
  balance      Decimal              @default(0.00) @db.Decimal(10, 2)
  currency     String               @default("NGN")
  userId       String
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  transactions ProjectTransaction[]
  user         User                 @relation(fields: [userId], references: [id])

  @@map("projects")
}

model ProjectTransaction {
  id          String                 @id @default(uuid())
  amount      Decimal                @db.Decimal(10, 2)
  type        ProjectTransactionType
  category    String?
  description String?
  date        DateTime               @default(now())
  projectId   String
  createdAt   DateTime               @default(now())
  updatedAt   DateTime               @updatedAt
  project     Project                @relation(fields: [projectId], references: [id])
  witnesses   Witness[]

  @@map("project_transactions")
}

model Promise {
  id          String        @id @default(uuid())
  description String
  promiseTo   String
  dueDate     DateTime
  notes       String?
  priority    Priority      @default(MEDIUM)
  category    String?
  status      PromiseStatus @default(PENDING)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  userId      String
  user        User          @relation(fields: [userId], references: [id])

  @@map("promises")
}

model AccessGrant {
  id        String       @id @default(uuid())
  email     String
  token     String       @unique
  status    AccessStatus @default(PENDING)
  createdAt DateTime     @default(now())
  expiresAt DateTime?
  granterId String
  granter   User         @relation(fields: [granterId], references: [id])

  @@map("access_grants")
}

model ExchangeRate {
  id          String   @id @default(uuid())
  from        String
  to          String
  rate        Decimal  @db.Decimal(18, 8)
  provider    String
  lastUpdated DateTime @default(now())

  @@unique([from, to])
  @@map("exchange_rates")
}

model ExchangeRateHistory {
  id        String   @id @default(uuid())
  from      String
  to        String
  rate      Decimal  @db.Decimal(18, 8)
  provider  String
  createdAt DateTime @default(now())

  @@index([from, to, createdAt])
  @@map("exchange_rate_history")
}

model ContactInvitation {
  id            String           @id @default(uuid())
  token         String           @unique
  status        InvitationStatus @default(PENDING)
  createdAt     DateTime         @default(now())
  expiresAt     DateTime
  acceptedAt    DateTime?
  contactId     String
  inviterId     String
  invitedUserId String?
  contact       Contact          @relation(fields: [contactId], references: [id], onDelete: Cascade)
  invitedUser   User?            @relation("InvitedUser", fields: [invitedUserId], references: [id])
  inviter       User             @relation("InviterUser", fields: [inviterId], references: [id])

  @@map("contact_invitations")
}

enum ReturnDirection {
  TO_ME
  TO_CONTACT
}

enum AssetCategory {
  FUNDS
  ITEM
}

enum TransactionType {
  GIVEN
  RECEIVED
  RETURNED
  GIFT
  EXPENSE
  INCOME
}

enum TransactionStatus {
  PENDING
  COMPLETED
  CANCELLED
}

enum WitnessStatus {
  PENDING
  ACKNOWLEDGED
  DECLINED
  MODIFIED
}

enum ProjectTransactionType {
  INCOME
  EXPENSE
}

enum Priority {
  HIGH
  MEDIUM
  LOW
}

enum PromiseStatus {
  PENDING
  FULFILLED
  OVERDUE
}

enum AccessStatus {
  PENDING
  ACCEPTED
  REVOKED
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

enum SubscriptionTier {
  FREE
  PRO
}

model Support {
  id              String             @id @default(uuid())
  amount          Decimal            @db.Decimal(20, 2)
  currency        String             @default("NGN")
  status          SupportStatus      @default(PENDING)
  paymentProvider String? // e.g., "paystack", "stripe"
  paymentRef      String?            @unique
  supporterId     String?
  supporterName   String?
  supporterEmail  String?
  message         String?
  isAnonymous     Boolean            @default(false)
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt

  supporter User? @relation(fields: [supporterId], references: [id])

  @@map("supports")
}

enum SupportStatus {
  PENDING
  SUCCESSFUL
  FAILED
}
